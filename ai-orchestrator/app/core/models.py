"""Core data models for the AI Orchestrator v2.0.

This module defines the data structures used across the orchestrator:
- ExecutionPlan: Multi-step task plan
- ExecutionStep: Single step in a plan
- StepResult: Result from executing a step

Requirements: Architecture v2.0
"""

from typing import Any, Literal

from pydantic import BaseModel, Field


class ExecutionStep(BaseModel):
    """A single step in an execution plan.

    Attributes:
        step_id: Unique identifier for this step (1-indexed)
        action: Human-readable action description
        tool: Name of the tool to execute
        tool_params: Parameters to pass to the tool
        depends_on: List of step_ids this step depends on
        reason: Why this step is needed
        estimated_cost: Estimated credit cost
    """

    step_id: int = Field(ge=1, description="Step ID (1-indexed)")
    action: str = Field(description="Action description")
    tool: str = Field(description="Tool name to execute")
    tool_params: dict[str, Any] = Field(
        default_factory=dict, description="Tool parameters"
    )
    depends_on: list[int] = Field(
        default_factory=list, description="Dependent step IDs"
    )
    reason: str = Field(description="Why this step is needed")
    estimated_cost: float = Field(default=0.0, description="Estimated credit cost")


class ExecutionPlan(BaseModel):
    """Complete execution plan for a user request.

    Generated by the Planner node, contains all steps needed
    to fulfill the user's request.

    Attributes:
        goal: The user's goal in natural language
        complexity: Task complexity level
        steps: List of execution steps
        estimated_total_credits: Total estimated credit cost
        requires_confirmation: Whether user confirmation is needed
    """

    goal: str = Field(description="User's goal")
    complexity: Literal["simple", "moderate", "complex"] = Field(
        description="Task complexity"
    )
    steps: list[ExecutionStep] = Field(description="Execution steps")
    estimated_total_credits: float = Field(
        default=0.0, description="Total estimated credits"
    )
    requires_confirmation: bool = Field(
        default=False, description="Whether confirmation is needed"
    )

    @property
    def step_count(self) -> int:
        """Number of steps in the plan."""
        return len(self.steps)

    def get_step(self, step_id: int) -> ExecutionStep | None:
        """Get a step by ID."""
        for step in self.steps:
            if step.step_id == step_id:
                return step
        return None


class StepResult(BaseModel):
    """Result from executing a single step.

    Attributes:
        step_id: The step that was executed
        tool: Tool that was called
        success: Whether execution succeeded
        data: Result data from the tool
        error: Error message if failed
        credit_consumed: Actual credits consumed
    """

    step_id: int
    tool: str
    success: bool
    data: Any = None
    error: str | None = None
    credit_consumed: float = 0.0

    @classmethod
    def from_tool_result(
        cls, step_id: int, tool: str, tool_result: Any
    ) -> "StepResult":
        """Create StepResult from a ToolResult."""
        from app.tools.base import ToolResult

        if isinstance(tool_result, ToolResult):
            return cls(
                step_id=step_id,
                tool=tool,
                success=tool_result.success,
                data=tool_result.data,
                error=tool_result.error,
                credit_consumed=tool_result.credit_consumed,
            )
        # Handle dict-like result
        return cls(
            step_id=step_id,
            tool=tool,
            success=tool_result.get("success", False),
            data=tool_result.get("data"),
            error=tool_result.get("error"),
            credit_consumed=tool_result.get("credit_consumed", 0.0),
        )
